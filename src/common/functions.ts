import { AuthenticationError } from 'apollo-server'
import { addHours, getTime, differenceInHours } from 'date-fns'
import { checkIsAuthenticated, AvailableScopes } from './permissions'
import { GraphQLPageInfo, GraphQLNode, GraphQLMutationResponse } from '../resolvers/graphql-resolvers-types'
import jwt from 'jwt-simple'
import { isJWT } from 'validator'
import { Context } from './utils'
import { users } from '../../data'

/**
 * ! The jwt secret is here just to not complicate the codes. A good practice is store it in process.env.JWT_SECRET !
 * @see https://passwordsgenerator.net/
 */
const JWT_SECRET = 'X+T4Qa-kx-yG36Gz'
const maxJWTValidityHours = 24

/**
 * The payload shape of all tokens generated by the "createJWT" function.
 */
export type JWTPayload = {
  /** Id do usu√°rio registrado no token. */
  subject: string,
  /** List of scopes this token has access to. */
  scopes: Array<keyof typeof AvailableScopes>,
  /** JavaScript date timestamp. */
  issuedAt: number,
  /** JavaScript date timestamp. */
  expiresIn: number,
  /** Address of the route that generated the token. */
  issuer?: string,
}

/**
 * Create a JSON Web Token (JWT) so that the "verifyJWT" function can securely verify
 * which user is trying to access the api.
 * @see https://jwt.io/
 *
 * @param subject Id of the user who generated the token.
 * @param issuer Address of the route that generated the token.
 */
export async function createJWT (subject: string, issuer?: string) {
  const expiresIn = addHours(Date.now(), maxJWTValidityHours)
  const payload: JWTPayload = {
    subject,
    scopes: ['read:tweets', 'read:users', 'write:tweets', 'write:users'],
    issuedAt: Date.now(),
    expiresIn: getTime(expiresIn),
    issuer,
  }

  return {
    token: jwt.encode(payload, JWT_SECRET),
    expiresIn
  }
}

/**
 * Verify that the request contains a valid JWT token created by the "createJWT" function.
 * @see https://jwt.io/
 *
 * @param isRequired If false, the request will be accepted even if a token is not found. Default = true
 * @throws Throws an error if a problem occurs while validating the token.
 * @returns Returns the payload of token if all goes well or returns null if no token is found.
 */
export async function verifyJWT (authorizationToken: string, isRequired = true) {
  // Check if there is a token in the request
  if (!authorizationToken || authorizationToken.trim() === '') {
    // Allow access if authentication is optional, otherwise block request
    if (isRequired === false) return null
    else throw new AuthenticationError('Token jwt not found.')
  }

  // Verify if token is well formatted ("Bearer 1234.5678.91011")
  const [scheme, token] = authorizationToken.split(' ')
  if (
    typeof scheme === 'undefined' ||
    scheme !== 'Bearer' ||
    typeof token === 'undefined' ||
    token.trim() === '' ||
    !isJWT(token)
  ) {
    throw new AuthenticationError('Jwt token is in an invalid format.')
  }

  // Attempt to validate received token
  let payload: JWTPayload
  try {
    payload = jwt.decode(token, JWT_SECRET)
  }
  catch (err) {
    // console.log('jwt.decode error:', err)
    throw new AuthenticationError('Unable to validate received jwt token.')
  }

  // Check if the token has expired
  if (differenceInHours(Date.now(), payload.issuedAt) > maxJWTValidityHours) {
    throw new AuthenticationError('Token jwt has expired.')
  }

  // Allow access!
  return payload
}


/**
 * Function to be used within resolvers to get informations of logged in user.
 * @throws Throws an error if no users are found.
 * @returns Returns an object with user infos.
 *
 * @example
 * async resolver(_, args, context) {
 *   await checkIsAuthenticated(context)
 *   const currentUser = await getLoggedUser(context)
 *   ...
 * }
 */
export async function getLoggedUser (context: Context) {
  await checkIsAuthenticated(context)

  return context.user!
}

export function findUserById (id: string) {
  return users.find(user => user.id === id)
}

type PaginatedResponseArgs<Node> = {
  allNodes: Node[],
  nodes: Node[],
  firstArg: number,
  startIndex: number,
}

/**
 * @returns An object with the default shape of GraphQL paginations.
 */
export function defaultConnectionShape<NodeType extends GraphQLNode> (
  { allNodes, nodes, firstArg, startIndex }: PaginatedResponseArgs<NodeType>
) {
  const firstItem = nodes[0]
  const lastItem = nodes[nodes.length - 1]
  const hasAtLeast1Item = (nodes.length >= 1)
  const pageInfo: GraphQLPageInfo = {
    size: Math.min(firstArg, nodes.length),
    startCursor: hasAtLeast1Item ? encode(firstItem.id) : null,
    endCursor: hasAtLeast1Item ? encode(lastItem.id) : null,
    hasPreviousPage: startIndex > 0,
    hasNextPage: (startIndex + firstArg) < allNodes.length,
  }

  return {
    nodes,
    pageInfo,
    totalCount: allNodes.length
  }
}

interface ResponseShape extends GraphQLMutationResponse {
  success: boolean,
  message: string,
  node?: any,
}
/**
 * Force resolver to return a response with a default format to the client.
 */
export function defaultResponseShape<R extends ResponseShape> (response: R): R {
  return response
}

/**
 * Encode a string to base64 (using the Node built-in Buffer).
 * Stolen from http://stackoverflow.com/a/38237610/2115623
 */
export function encode (text: string | number) {
  return Buffer.from(String(text)).toString('base64')
}

type Base64String = string

/**
 * Decode a base64 string (using the Node built-in Buffer).
 * Stolen from http://stackoverflow.com/a/38237610/2115623
 */
export function decode (encodedText: Base64String) {
  return Buffer.from(encodedText, 'base64').toString('ascii')
}
